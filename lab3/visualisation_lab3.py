import math

import sympy
from sympy import *
from sympy.abc import x
import matplotlib.pyplot as plt
fig,axes=plt.subplots(1,2)
def intsum(fun,a,b,n,osn):
    sum=0
    x_list=[]#список точек по оси икс для 1 графика
    y1_list=[]#список точек интегральной суммы для 1 графика
    y2_list=[]#список точек значений функции для 1 графика
    x1_list=[]#список точек по оси икс для 2 графика
    y3_list=[]#список точек значений функции на (a,b) для 2 графика
    axes[0].grid()#делаем сеть
    axes[1].grid()  # делаем сеть
    for j in range(a,b):
        x1_list.append(j) #добавляем точки в список точек по оси икс на (a,b) для 2 графика
        y3_list.append(fun.subs(x,j)) #считаем значение функции при оснащении на (a,b) для 2 графика

    for i in range(len(osn)):#идем по всем точкам оснащения
        x_list.append(i)#добавляем точки в список точек по оси икс
        sum+=((b-a)/n)*fun.subs(x,osn[i])#считаем значение текущей интегральной суммы
        t=fun.subs(x,osn[i])#считаем значение функции при оснащении
        y1_list .append(sum)#добавляем в список точек интегральной суммы
        y2_list.append(t)#добавляем в список точек значений функции при оснащении
        axes[0].plot(x_list ,y1_list ,label="интегральная сумма")#строим график интегральной суммы
        axes[0].plot(x_list, y2_list,label="функция при оснащении",marker="." )#строим график функции при заданном оснащении
        axes[1].plot(x1_list, y3_list, label="график функции на (a,b)",marker=".")  # строим график функции на (a,b) для 2 графика
    print(sum)
osn=[]
f=0
for i in range(1000):
    f+=4/1000
    osn.append(f)
intsum(1+x+cos(x*math.pi*0.5) ,0,4,10,osn)#читаем сумму из задания для нашего примера с достаточно большой точностью
#как видно по результатам аналитической части и в сравнении с прочими оснащниями результат близок при достаточно больших
# n однако погрешность все равно присутствует в силу специфики сложения чисел с плавующей точкой в системе компьютера
plt.show()
